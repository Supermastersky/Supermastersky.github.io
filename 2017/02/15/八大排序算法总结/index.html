<!doctype html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="MasterSky" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="八大排序算法总结一、概述1、什么是排序所谓排序，就是把集合中的数据元素，按它们的关键字非递减或非递增序，排成一个序列。
2、排序的分类（1）内排序和外排序按排序数据元素的的位置，可将排序分为内排序与外排序两类。
外排序外排序是指在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置。通常在排序数据较大情况下，内存不足以放入所有数据进行处理，此时需考虑进行外排序。">
<meta property="og:type" content="article">
<meta property="og:title" content="八大排序算法总结">
<meta property="og:url" content="http://supermastersky.com/2017/02/15/八大排序算法总结/index.html">
<meta property="og:site_name" content="MasterSky">
<meta property="og:description" content="八大排序算法总结一、概述1、什么是排序所谓排序，就是把集合中的数据元素，按它们的关键字非递减或非递增序，排成一个序列。
2、排序的分类（1）内排序和外排序按排序数据元素的的位置，可将排序分为内排序与外排序两类。
外排序外排序是指在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置。通常在排序数据较大情况下，内存不足以放入所有数据进行处理，此时需考虑进行外排序。">
<meta property="og:updated_time" content="2017-04-06T08:34:27.453Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="八大排序算法总结">
<meta name="twitter:description" content="八大排序算法总结一、概述1、什么是排序所谓排序，就是把集合中的数据元素，按它们的关键字非递减或非递增序，排成一个序列。
2、排序的分类（1）内排序和外排序按排序数据元素的的位置，可将排序分为内排序与外排序两类。
外排序外排序是指在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置。通常在排序数据较大情况下，内存不足以放入所有数据进行处理，此时需考虑进行外排序。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://supermastersky.com/2017/02/15/八大排序算法总结/"/>





  <title> 八大排序算法总结 | MasterSky </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MasterSky</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://supermastersky.com/2017/02/15/八大排序算法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MasterSky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                八大排序算法总结
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-15T21:43:32+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="八大排序算法总结"><a href="#八大排序算法总结" class="headerlink" title="八大排序算法总结"></a>八大排序算法总结</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1、什么是排序"><a href="#1、什么是排序" class="headerlink" title="1、什么是排序"></a>1、什么是排序</h3><p>所谓排序，就是把集合中的数据元素，按它们的关键字非递减或非递增序，排成一个序列。</p>
<h3 id="2、排序的分类"><a href="#2、排序的分类" class="headerlink" title="2、排序的分类"></a>2、排序的分类</h3><h4 id="（1）内排序和外排序"><a href="#（1）内排序和外排序" class="headerlink" title="（1）内排序和外排序"></a>（1）内排序和外排序</h4><p>按排序数据元素的的位置，可将排序分为内排序与外排序两类。</p>
<h5 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h5><p>外排序是指在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置。通常在排序数据较大情况下，内存不足以放入所有数据进行处理，此时需考虑进行外排序。<br>外排序效率提高依赖于减少外存储器的读写。最常用的是【归并排序】（只需访问序列中第一个元素，适合于顺序文件）。<br>通过进行2路归并、多路归并等方式，进行逐步归并。本文仅以此简略介绍。</p>
<h5 id="内排序"><a href="#内排序" class="headerlink" title="内排序"></a>内排序</h5><p>内排序是指被排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置。</p>
<h5 id="通常所说的【八大排序】均指内部排序（在内存中进行的排序）。"><a href="#通常所说的【八大排序】均指内部排序（在内存中进行的排序）。" class="headerlink" title="通常所说的【八大排序】均指内部排序（在内存中进行的排序）。"></a>通常所说的【八大排序】均指内部排序（在内存中进行的排序）。</h5><h4 id="（2）稳定排序和非稳定排序"><a href="#（2）稳定排序和非稳定排序" class="headerlink" title="（2）稳定排序和非稳定排序"></a>（2）稳定排序和非稳定排序</h4><p>稳定与非稳定排序：假定在待排序的集合中存在多个【关键字值相同】的数据元素。如果经过排序后，【这些数据元素的相对次序保持不变，则称为稳定排序；否则称为不稳定排序。】</p>
<h3 id="3、排序的时间复杂度"><a href="#3、排序的时间复杂度" class="headerlink" title="3、排序的时间复杂度"></a>3、排序的时间复杂度</h3><p>由于外部排序的单次磁盘读写操作耗时较多，本文暂不进行探讨，对内部排序的时间复杂度进行分类。<br>按内部排序过程中的工作量进行分类，可大致分为3类。<br>（1）简单的。时间复杂度O(N2)<br>（2）先进的。时间复杂度O(NlogN)<br>（3）基数排序。时间复杂度O(D.N)</p>
<h3 id="4、两种排序基本操作"><a href="#4、两种排序基本操作" class="headerlink" title="4、两种排序基本操作"></a>4、两种排序基本操作</h3><h4 id="（1）关键字比较"><a href="#（1）关键字比较" class="headerlink" title="（1）关键字比较"></a>（1）关键字比较</h4><p>关键字比较对大多数排序方法来说是必要的。</p>
<h4 id="（2）记录移动"><a href="#（2）记录移动" class="headerlink" title="（2）记录移动"></a>（2）记录移动</h4><p>可通过改变记录的存储方式来予以避免。<br>通常有3种记录存储方式。<br>存储方式1：顺序存储结构<br>存储方式2：静态链表。关系次序由指针指示，排序时不移动记录，仅修改指针。<br>存储方式3：地址排序。排序过程中不移动记录，移动地址向量中的地址。排序结束后再按照地址向量值调整位置。</p>
<h2 id="二、八大排序介绍"><a href="#二、八大排序介绍" class="headerlink" title="二、八大排序介绍"></a>二、八大排序介绍</h2><h4 id="可分为插入排序、选择排序、交换排序、归并排序、基数排序5类。"><a href="#可分为插入排序、选择排序、交换排序、归并排序、基数排序5类。" class="headerlink" title="可分为插入排序、选择排序、交换排序、归并排序、基数排序5类。"></a>可分为插入排序、选择排序、交换排序、归并排序、基数排序5类。</h4><h3 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h3><p>【原理】：首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的n-1个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的。<br>【类比成打牌，右手牌原数量为n，需全部转移到左手且有序。左手的牌数量从0-n，每增长一张牌后都是有序的】</p>
<h4 id="（1）直接插入排序"><a href="#（1）直接插入排序" class="headerlink" title="（1）直接插入排序"></a>（1）直接插入排序</h4><h5 id="1°算法介绍"><a href="#1°算法介绍" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>假定待排序的是数组a，它共有n个 数组元素。那么对于每个1 &lt;=j&lt;n的j，将a[j]插入到已经排好序的序列a[0], a[1], a[2],……, a[j-1] 中去。<br>首先将a[j]放入到一个某个变量tmp中。然后从右到左与a[j-1]……, a[2], a[1], a[0]，进行比较。<br>-若tmp &lt; a[j-1]，将a[j-1]的内容移到a[j]中去；<br>-接下来，若 tmp  &lt; a[j-2]，继续将a[j-2]的内容移到a[j-1]中去。<br>-重复这个过程，直至找到比tmp小的数组元素a[k]，将tmp存入a[k+1]。<br>-如果一直找到a[0]都没有找到一个小于tmp的值，将tmp存入a[0]。</p>
<p>【也就是，从右向左逐个比较，若比原位置大就停；否则原位置的右移，再和左边的比】</p>
<h5 id="2°性能分析"><a href="#2°性能分析" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>【时间复杂度是O(N2)】。该上限是可达的。当输入是逆序，最坏情况时，达到上限。<br>最好情况下，当输入已排序时，因为内层循环只执行一个周期，运行时间是O(N)，正序时比较次数n-1，移动0。<br>平均情况下，时间复杂度n2/4，O(n2)。</p>
<p>简单易于实现。稳定。关键字相同的2个元素，不会通过比较而互换。<br>【适用于】排序元素较少，且【几乎已排序（接近正序）】的情况。</p>
<h4 id="（2）希尔（Shell）排序【缩小增量排序】"><a href="#（2）希尔（Shell）排序【缩小增量排序】" class="headerlink" title="（2）希尔（Shell）排序【缩小增量排序】"></a>（2）希尔（Shell）排序【缩小增量排序】</h4><p>【基本思想】<br>在插入排序中，只比较相邻的结点，一次比较最多把结点移动一个位置。如果对位置间隔较大距离的结点进行比较，使得结点在比较以后能够一次跨过较大的距离，这样就可以提高排序的速度。</p>
<h5 id="1°算法介绍-1"><a href="#1°算法介绍-1" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>设待排序的对象序列有n个对象，首先取一个整数gap&lt;n作为增量，将全部对象分为gap个子序列，所有距离为gap的对象放在同一个序列中，在每一个子序列中分别施行直接插入排序。<br>然后缩小增量gap，如取gap=gap/2。<br>重复上述的子序列划分和排序工作，直到最后取gap为1为止。<br>【即：先分组，在每一组内进行（序列长度较小）的插入排序，再逐渐增加序列长度，进行微调。即对于逐渐有序的总序列不断进行插入排序】</p>
<h5 id="2°性能分析-1"><a href="#2°性能分析-1" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>希尔排序的时间复杂度不确定。【难以分析】<br>在O(n(3/2))~O（n（log2n)2）区间内<br>【希尔排序，是不稳定的排序方法。因为“不相邻记录间的移动”，可能改变相同关键字的次序】</p>
<h3 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h3><p>【原理】：将待排序的结点分为已排序(初始为空)和为未排序两组，依次将未排序的结点中值最小的结点插入已排序的组中。</p>
<h4 id="（1）直接（简单）选择排序"><a href="#（1）直接（简单）选择排序" class="headerlink" title="（1）直接（简单）选择排序"></a>（1）直接（简单）选择排序</h4><h5 id="1°算法介绍-2"><a href="#1°算法介绍-2" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>首先在所有元素中用逐个比较的方法选出最小元素，把它与第一个元素交换；然后在剩下的元素中再次用逐个比较的方法选出最小元素，把它与第二个元素交换；以此类推，直到所有元素放入正确的位置。</p>
<p>对k个元素而言，每次选出最小元素需要k-1次比较。因此排序一个n个元素组成的序列所需的比较次数为：<br>(n-1) + (n-2)+ …… + 2 + 1  = n(n-1)/2 = O(n2)<br>【即采用“先找最小，再和第x序列交换”的方式】<br>直接选择排序是稳定的。</p>
<h4 id="（2）树形选择"><a href="#（2）树形选择" class="headerlink" title="（2）树形选择"></a>（2）树形选择</h4><h5 id="1°算法介绍-3"><a href="#1°算法介绍-3" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>【这是对简单选择排序，利用上次结果，加以改进的方法】<br>对于次小元素，利用上次的结果，即被13打败的结点中进行比较。具体而言，可以将叶结点中的最小值改为∞，重新比较。</p>
<h5 id="2°性能分析-2"><a href="#2°性能分析-2" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>考虑关键字的比较次数和对象移动次数。<br>比较次数为 O(log2n)（最小关键字需 n-1 次）<br>对象的移动次数不超过比较次数。<br>所以，总的时间复杂度为O(n log2n)空间复杂度为O(n)<br>树形选择排序是稳定的排序方法。<br>缺点：辅助存储空间较多，和最大值进行多余的比较。<br>【树形选择排序可以进一步优化为堆排序，通常不作为“八大排序算法”之一】</p>
<h4 id="（3）堆排序"><a href="#（3）堆排序" class="headerlink" title="（3）堆排序"></a>（3）堆排序</h4><p>【堆分为最小化堆/最大化堆，首先是完全二叉树】<br>对于最小/最大化堆，每个父亲都小于/大于它的2个儿子；儿子之间大小关系不一定；上下层之间也不一定。<br>【需写成完全二叉树的形式再进行判别】</p>
<h5 id="1°算法介绍-4"><a href="#1°算法介绍-4" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>使用递归实现。<br>-初始建堆，并调整至最大化/最小化堆<br>-将堆根的元素（最大/最小元素）依次和最右、最下的元素互换（逆层序遍历）<br>【也可以将最大元素去除，并重新调整堆（算法2）】<br>-只剩最后1个元素时，结束。</p>
<h5 id="2°性能分析-3"><a href="#2°性能分析-3" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>时间复杂度：<br>时间耗费的代价：建堆的时间耗费＋排序的时间耗费。<br>前者的T(n) = O (n) 【约4n】<br>后者的T(n) = O (nlogn)<br>最后所得的T(n) = O (nlogn)，这里取大的。【系数大约是2】。<br>最坏情况下，时间复杂度为O(nlogn) ，比快速排序优。但平均情况下，比快速排序差<br>空间复杂度：O(1)，仅需一个记录大小供交换用的辅助存储空间<br>不稳定。<br>【堆排序和快速排序各有所长。最坏情况下的时间复杂度不会退化，但平均情况下的时间复杂度系数比快速排序要大】</p>
<h3 id="3、交换排序（快速排序、冒泡排序）"><a href="#3、交换排序（快速排序、冒泡排序）" class="headerlink" title="3、交换排序（快速排序、冒泡排序）"></a>3、交换排序（快速排序、冒泡排序）</h3><p>【原理】<br>根据序列中两个数据元素的比较结果，确定是否交换这两个数据元素在序列中的位置。<br>【特点】：通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动。</p>
<h4 id="（1）冒泡排序"><a href="#（1）冒泡排序" class="headerlink" title="（1）冒泡排序"></a>（1）冒泡排序</h4><h5 id="1°算法介绍-5"><a href="#1°算法介绍-5" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一ci次【起泡】。</p>
<p>然后再从头开始，对倒数第二个元素进行第二次起泡。经过了第二次比较，又将第二大的元素放到了倒数第二个位置。依次类推，经过第n-1次起泡，将倒数第n-1个大的元素放入第2个单元。<br>【注：冒泡排序中，使用1个标志位，来记录起泡中有没有发生过交换（初值为False，如果交换则设定为True）；如果没有，则前面的是已排序的】-作为【结束条件】</p>
<h5 id="2°性能分析-4"><a href="#2°性能分析-4" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>【最坏情况，进行n-1次起泡操作，第i次起泡，需n-1次比较、n-i次交换。O(N2)】<br>【最好情况，顺序，1次起泡，n-1次比较（此时标志位没有变化，循环结束），O(N)】<br>【平均情况，时间复杂度 O(N2)】<br>冒泡排序【适合原始数据较为有序的情况】<br>**和简单选择排序较为相似。</p>
<h4 id="（2）快速排序"><a href="#（2）快速排序" class="headerlink" title="（2）快速排序"></a>（2）快速排序</h4><h5 id="1°算法介绍-6"><a href="#1°算法介绍-6" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>在待排序的序列中选择一个数据元素，以该元素为标准，将所有数据元素分为两组，第一组的元素均小于或等于标准元素，第二组的数据元素均大于标准元素。<br>第一组的元素放在数组的前面部分，第二组的数据元素放在数组的后面部分，标准元素放在中间。这个位置就是标准元素的最终位置。这称为一次划分。<br>然后对分成的两组数据重复上述过程，直到所有的元素都在适当的位置为止。<br>【采用递归算法实现】</p>
<p>选择中心点<br>-用待排序序列的第一个元素作为标准元素。【如果输入随机，可以接受；这个对有序情况是糟糕的划分。】<br>-【选择N个数的中值，保证均匀划分（可以通过采样得到）】<br>-【最左、最右、中间3个元素值处于中间的作为枢轴】</p>
<p>如何划分<br>-从右向左开始检查。如果high的值大于k，该位置中的值位置正确，high减1，继续往前检查，直到遇到一个小于k的值。<br>-将小于k的这个值放入low的位置。此时high的位置又空出来了。然后从low位置开始从左向右检查，直到遇到一个大于k的值。<br>-将low位置的值放入high位置，重复第一步，直到low和high重叠。将k放入此位置。</p>
<p>【即：先从右往左，如果是大于k则过，high左移；如果小于k，则把值和low互换。再从左往右继续找小于k的，同理进行。直到有大于k的，把这个值放入high位置，重复第一步。直到low和high重叠（low≥high）。】<br>【先排序；再分别排序左、右一半】</p>
<h5 id="2°性能分析-5"><a href="#2°性能分析-5" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>【最坏情况，中心点最小或最大，时间复杂度O(N2)】<br>【最好情况，中心点划分成两个相同规模子集，O(N logN)】-两边同时除以N，求和】<br>【平均情况，O(N logN)】<br>**【通常认为，快速排序是在平均情况下最佳的排序方法。】<br>缺陷：<br>-枢轴选择不当可能导致最坏情况出现。<br>-差不多排好序时，采用直接插入排序、起泡排序等方法。<br>-递归改为非递归<br>空间复杂度不超过logN。</p>
<h3 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h3><p>【原理】<br>来自于【归并有序表/有序链表】<br>-顺序比较对应元素，小者移入另一表/新表（可采用指针移动，链表同理）<br>-一表空，另一表剩余结点自左至右复制/直接链表链上去。</p>
<h5 id="1°算法介绍-7"><a href="#1°算法介绍-7" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>若N = 1，已排序。<br>否则，<br>-前一半和后一半分别归并排序<br>-归并两个已排序数组<br>【递归分治，参数是排序的区间】<br>-可以采用以下函数。<br>MSort( RcdType SR[ ], RcdType &amp;TR1[ ], int s, int t  )【将 SR[s..t] 归并为 TR1 [ s..t]】SR代表原来的【序列】；TR1代表之后的【序列】。s代表头结点，t代表尾结点。<br>if  ( s == t ) TR1[s] = SR[s];     else</p>
<pre><code>{  m = ( S+ t)/2 ;        // 将SR[s..t]分为SR[s..m]和SR[m+1..t]
      Msort(SR,TR2,s,m);        // 递归地将SR[s..m]归并为有序的TR2[s..m]
      Msort(SR,TR2,m+1, t);    // 递归地将SR[m+1..t]归并为有序的TR2[m+1..t] 

  Merge(TR2,TR1,s,m, t);   // 将TR2[s..m]和TR2[m+1..t] 归并到TR1[s..t]
   }
</code></pre><h5 id="2°性能分析-6"><a href="#2°性能分析-6" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>【归并次数：log N，每次比较的代价N；总时间代价为O(N logN)】<br>空间复杂度：O(N)<br>稳定。</p>
<h3 id="5、基数排序"><a href="#5、基数排序" class="headerlink" title="5、基数排序"></a>5、基数排序</h3><p>【原理】<br>把单关键字按基数分成“多关键字”来排序。</p>
<h5 id="1°算法介绍-8"><a href="#1°算法介绍-8" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>多关键字排序：<br>【多个关键字排序时，关键字之间的关系是按字段升/降序的，而不是加权】<br>（即：最主＞次主＞……＞最次）<br>-最高位优先【MSD】<br>先对最高位排序，按不同值将记录序列分为若干子序列，再对次高位排序，……最后对最次位关键字排序。<br>-最低位优先【LSD】<br>先对最低位排序，再……这样不需要根据“前一个”关键字的排序结果，将记录序列分割成若干个(“前一个”关键字不同的)子序列。<br>【即：先按每个关键字分开排序；再按某种特定方式（从高到低）收集】<br>e.g.对一群不大于1000的数排序。【要确定规则】<br>-先看位数分类（分开）<br>-再按最高位、次高位等确定大小（排序）<br>-多位比少位大，高位数大的大（收集）</p>
<h5 id="2°性能分析-7"><a href="#2°性能分析-7" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>【时间复杂度：每个结点d位关键字，d次分配和收集】<br>分配：O(N)，收集O(rd)。总代价为O(d* (n+rd))</p>
<h2 id="三、【各种内部排序方法比较】"><a href="#三、【各种内部排序方法比较】" class="headerlink" title="三、【各种内部排序方法比较】"></a>三、【各种内部排序方法比较】</h2><h3 id="1、时间性能"><a href="#1、时间性能" class="headerlink" title="1、时间性能"></a>1、时间性能</h3><p>（1）【按平均时间性能】：<br>O(nlogn)的方法有：【快速排序、堆排序和归并排序】，其中以【快速排序】为最好；<br>O(n2)的方法有：【直接插入排序、起泡排序和简单选择排序】，其中以【直接插入】为最好，特别是对那些对关键字近似有序的记录序列尤为如此。<br>时间复杂度为O(n)的排序方法只有，基数排序。<br>【这里不考虑希尔排序】</p>
<p>（2）【待排记录序列按关键字顺序有序】：<br>【直接插入排序和起泡排序】能达到O(n)的时间复杂度。<br>对快速排序而言，这是最不好的情况，此时的时间性能蜕化为O(n2)，应尽量避免。</p>
<p>（3）【简单选择排序、堆排序和归并排序】的时间性能不随序列中关键字的分布而改变。<br>（2、3两部分没有考虑希尔排序、基数排序）</p>
<h3 id="2、空间性能"><a href="#2、空间性能" class="headerlink" title="2、空间性能"></a>2、空间性能</h3><p>（1）所有的【简单排序方法(包括：直接插入、起泡和简单选择)和堆排序】的空间复杂度为O(1)；<br>（2） 快速排序为O(logn)，为栈所需的辅助空间；<br>（3） 【归并排序所需辅助空间最多】，其空间复杂度为O(n)；<br>（4）【链式基数排序需附设队列首尾指针】，则空间复杂度为O(n+2rd)。</p>
<h3 id="3、稳定性"><a href="#3、稳定性" class="headerlink" title="3、稳定性"></a>3、稳定性</h3><p>前面的3大类排序，都是简单的稳定，复杂（相对高效）的不稳定。</p>
<h4 id="（1）稳定："><a href="#（1）稳定：" class="headerlink" title="（1）稳定："></a>（1）稳定：</h4><p>-直接插入排序（折半插入）<br>-直接选择排序（树形选择排序）<br>-冒泡排序<br>-归并排序<br>-基数排序</p>
<h4 id="（2）不稳定："><a href="#（2）不稳定：" class="headerlink" title="（2）不稳定："></a>（2）不稳定：</h4><p>-希尔排序<br>-堆排序<br>-快速排序</p>
<h3 id="4、关于“比较关键字”原理排序的时间复杂度"><a href="#4、关于“比较关键字”原理排序的时间复杂度" class="headerlink" title="4、关于“比较关键字”原理排序的时间复杂度"></a>4、关于“比较关键字”原理排序的时间复杂度</h3><p>除基数排序外，其它方法都是基于“比较关键字”进行排序的排序方法，可以证明，这类排序法可能达到的最快的时间复杂度为O(nlogn)。(基数排序不是基于“比较关键字”的排序方法,所以它不受这个限制)</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/28/hello-world/" rel="prev" title="Hello World">
                Hello World <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#八大排序算法总结"><span class="nav-number">1.</span> <span class="nav-text">八大排序算法总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、概述"><span class="nav-number">1.1.</span> <span class="nav-text">一、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、什么是排序"><span class="nav-number">1.1.1.</span> <span class="nav-text">1、什么是排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、排序的分类"><span class="nav-number">1.1.2.</span> <span class="nav-text">2、排序的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）内排序和外排序"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">（1）内排序和外排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#外排序"><span class="nav-number">1.1.2.1.1.</span> <span class="nav-text">外排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内排序"><span class="nav-number">1.1.2.1.2.</span> <span class="nav-text">内排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通常所说的【八大排序】均指内部排序（在内存中进行的排序）。"><span class="nav-number">1.1.2.1.3.</span> <span class="nav-text">通常所说的【八大排序】均指内部排序（在内存中进行的排序）。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）稳定排序和非稳定排序"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">（2）稳定排序和非稳定排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、排序的时间复杂度"><span class="nav-number">1.1.3.</span> <span class="nav-text">3、排序的时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、两种排序基本操作"><span class="nav-number">1.1.4.</span> <span class="nav-text">4、两种排序基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）关键字比较"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">（1）关键字比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）记录移动"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">（2）记录移动</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、八大排序介绍"><span class="nav-number">1.2.</span> <span class="nav-text">二、八大排序介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可分为插入排序、选择排序、交换排序、归并排序、基数排序5类。"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">可分为插入排序、选择排序、交换排序、归并排序、基数排序5类。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1、插入排序"><span class="nav-number">1.2.1.</span> <span class="nav-text">1、插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）直接插入排序"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">（1）直接插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1°算法介绍"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">1°算法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2°性能分析"><span class="nav-number">1.2.1.1.2.</span> <span class="nav-text">2°性能分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）希尔（Shell）排序【缩小增量排序】"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">（2）希尔（Shell）排序【缩小增量排序】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1°算法介绍-1"><span class="nav-number">1.2.1.2.1.</span> <span class="nav-text">1°算法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2°性能分析-1"><span class="nav-number">1.2.1.2.2.</span> <span class="nav-text">2°性能分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、选择排序"><span class="nav-number">1.2.2.</span> <span class="nav-text">2、选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）直接（简单）选择排序"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">（1）直接（简单）选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1°算法介绍-2"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">1°算法介绍</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）树形选择"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">（2）树形选择</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1°算法介绍-3"><span class="nav-number">1.2.2.2.1.</span> <span class="nav-text">1°算法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2°性能分析-2"><span class="nav-number">1.2.2.2.2.</span> <span class="nav-text">2°性能分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）堆排序"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">（3）堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1°算法介绍-4"><span class="nav-number">1.2.2.3.1.</span> <span class="nav-text">1°算法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2°性能分析-3"><span class="nav-number">1.2.2.3.2.</span> <span class="nav-text">2°性能分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、交换排序（快速排序、冒泡排序）"><span class="nav-number">1.2.3.</span> <span class="nav-text">3、交换排序（快速排序、冒泡排序）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）冒泡排序"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">（1）冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1°算法介绍-5"><span class="nav-number">1.2.3.1.1.</span> <span class="nav-text">1°算法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2°性能分析-4"><span class="nav-number">1.2.3.1.2.</span> <span class="nav-text">2°性能分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）快速排序"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">（2）快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1°算法介绍-6"><span class="nav-number">1.2.3.2.1.</span> <span class="nav-text">1°算法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2°性能分析-5"><span class="nav-number">1.2.3.2.2.</span> <span class="nav-text">2°性能分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、归并排序"><span class="nav-number">1.2.4.</span> <span class="nav-text">4、归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1°算法介绍-7"><span class="nav-number">1.2.4.0.1.</span> <span class="nav-text">1°算法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2°性能分析-6"><span class="nav-number">1.2.4.0.2.</span> <span class="nav-text">2°性能分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5、基数排序"><span class="nav-number">1.2.5.</span> <span class="nav-text">5、基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1°算法介绍-8"><span class="nav-number">1.2.5.0.1.</span> <span class="nav-text">1°算法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2°性能分析-7"><span class="nav-number">1.2.5.0.2.</span> <span class="nav-text">2°性能分析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、【各种内部排序方法比较】"><span class="nav-number">1.3.</span> <span class="nav-text">三、【各种内部排序方法比较】</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、时间性能"><span class="nav-number">1.3.1.</span> <span class="nav-text">1、时间性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、空间性能"><span class="nav-number">1.3.2.</span> <span class="nav-text">2、空间性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、稳定性"><span class="nav-number">1.3.3.</span> <span class="nav-text">3、稳定性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）稳定："><span class="nav-number">1.3.3.1.</span> <span class="nav-text">（1）稳定：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）不稳定："><span class="nav-number">1.3.3.2.</span> <span class="nav-text">（2）不稳定：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4、关于“比较关键字”原理排序的时间复杂度"><span class="nav-number">1.3.4.</span> <span class="nav-text">4、关于“比较关键字”原理排序的时间复杂度</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
