<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MasterSky</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://supermastersky.com/"/>
  <updated>2017-04-06T13:46:20.845Z</updated>
  <id>http://supermastersky.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>八大排序算法总结</title>
    <link href="http://supermastersky.com/2017/03/04/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://supermastersky.com/2017/03/04/八大排序算法总结/</id>
    <published>2017-03-04T10:43:32.000Z</published>
    <updated>2017-04-06T13:46:20.845Z</updated>
    
    <content type="html"><![CDATA[<p>最近复习数据结构与算法，归纳整理一下八大排序算法。</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1、什么是排序"><a href="#1、什么是排序" class="headerlink" title="1、什么是排序"></a>1、什么是排序</h3><p>所谓排序，就是把集合中的数据元素，按它们的关键字非递减或非递增序，排成一个序列。</p>
<h3 id="2、排序的分类"><a href="#2、排序的分类" class="headerlink" title="2、排序的分类"></a>2、排序的分类</h3><h4 id="（1）内排序和外排序"><a href="#（1）内排序和外排序" class="headerlink" title="（1）内排序和外排序"></a>（1）内排序和外排序</h4><p>按排序数据元素的的位置，可将排序分为内排序与外排序两类。<br>&lt;–!more–&gt;</p>
<h5 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h5><p>外排序是指在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置。通常在排序数据较大情况下，内存不足以放入所有数据进行处理，此时需考虑进行外排序。<br>外排序效率提高依赖于减少外存储器的读写。最常用的是【归并排序】（只需访问序列中第一个元素，适合于顺序文件）。<br>通过进行2路归并、多路归并等方式，进行逐步归并。本文仅以此简略介绍。</p>
<h5 id="内排序"><a href="#内排序" class="headerlink" title="内排序"></a>内排序</h5><p>内排序是指被排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置。</p>
<h5 id="通常所说的【八大排序】均指内部排序（在内存中进行的排序）。"><a href="#通常所说的【八大排序】均指内部排序（在内存中进行的排序）。" class="headerlink" title="通常所说的【八大排序】均指内部排序（在内存中进行的排序）。"></a>通常所说的【八大排序】均指内部排序（在内存中进行的排序）。</h5><h4 id="（2）稳定排序和非稳定排序"><a href="#（2）稳定排序和非稳定排序" class="headerlink" title="（2）稳定排序和非稳定排序"></a>（2）稳定排序和非稳定排序</h4><p>稳定与非稳定排序：假定在待排序的集合中存在多个【关键字值相同】的数据元素。如果经过排序后，【这些数据元素的相对次序保持不变，则称为稳定排序；否则称为不稳定排序。】</p>
<h3 id="3、排序的时间复杂度"><a href="#3、排序的时间复杂度" class="headerlink" title="3、排序的时间复杂度"></a>3、排序的时间复杂度</h3><p>由于外部排序的单次磁盘读写操作耗时较多，本文暂不进行探讨，对内部排序的时间复杂度进行分类。<br>按内部排序过程中的工作量进行分类，可大致分为3类。<br>（1）简单的。时间复杂度O(N2)<br>（2）先进的。时间复杂度O(NlogN)<br>（3）基数排序。时间复杂度O(D.N)</p>
<h3 id="4、两种排序基本操作"><a href="#4、两种排序基本操作" class="headerlink" title="4、两种排序基本操作"></a>4、两种排序基本操作</h3><h4 id="（1）关键字比较"><a href="#（1）关键字比较" class="headerlink" title="（1）关键字比较"></a>（1）关键字比较</h4><p>关键字比较对大多数排序方法来说是必要的。</p>
<h4 id="（2）记录移动"><a href="#（2）记录移动" class="headerlink" title="（2）记录移动"></a>（2）记录移动</h4><p>可通过改变记录的存储方式来予以避免。<br>通常有3种记录存储方式。<br>存储方式1：顺序存储结构<br>存储方式2：静态链表。关系次序由指针指示，排序时不移动记录，仅修改指针。<br>存储方式3：地址排序。排序过程中不移动记录，移动地址向量中的地址。排序结束后再按照地址向量值调整位置。</p>
<h2 id="二、八大排序介绍"><a href="#二、八大排序介绍" class="headerlink" title="二、八大排序介绍"></a>二、八大排序介绍</h2><h4 id="可分为插入排序、选择排序、交换排序、归并排序、基数排序5类。"><a href="#可分为插入排序、选择排序、交换排序、归并排序、基数排序5类。" class="headerlink" title="可分为插入排序、选择排序、交换排序、归并排序、基数排序5类。"></a>可分为插入排序、选择排序、交换排序、归并排序、基数排序5类。</h4><h3 id="1、插入排序"><a href="#1、插入排序" class="headerlink" title="1、插入排序"></a>1、插入排序</h3><p>【原理】：首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的n-1个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的。<br>【类比成打牌，右手牌原数量为n，需全部转移到左手且有序。左手的牌数量从0-n，每增长一张牌后都是有序的】</p>
<h4 id="（1）直接插入排序"><a href="#（1）直接插入排序" class="headerlink" title="（1）直接插入排序"></a>（1）直接插入排序</h4><h5 id="1°算法介绍"><a href="#1°算法介绍" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>假定待排序的是数组a，它共有n个 数组元素。那么对于每个1 &lt;=j&lt;n的j，将a[j]插入到已经排好序的序列a[0], a[1], a[2],……, a[j-1] 中去。<br>首先将a[j]放入到一个某个变量tmp中。然后从右到左与a[j-1]……, a[2], a[1], a[0]，进行比较。<br>-若tmp &lt; a[j-1]，将a[j-1]的内容移到a[j]中去；<br>-接下来，若 tmp  &lt; a[j-2]，继续将a[j-2]的内容移到a[j-1]中去。<br>-重复这个过程，直至找到比tmp小的数组元素a[k]，将tmp存入a[k+1]。<br>-如果一直找到a[0]都没有找到一个小于tmp的值，将tmp存入a[0]。</p>
<p>【也就是，从右向左逐个比较，若比原位置大就停；否则原位置的右移，再和左边的比】</p>
<h5 id="2°性能分析"><a href="#2°性能分析" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>【时间复杂度是O(N2)】。该上限是可达的。当输入是逆序，最坏情况时，达到上限。<br>最好情况下，当输入已排序时，因为内层循环只执行一个周期，运行时间是O(N)，正序时比较次数n-1，移动0。<br>平均情况下，时间复杂度n2/4，O(n2)。</p>
<p>简单易于实现。稳定。关键字相同的2个元素，不会通过比较而互换。<br>【适用于】排序元素较少，且【几乎已排序（接近正序）】的情况。</p>
<h4 id="（2）希尔（Shell）排序【缩小增量排序】"><a href="#（2）希尔（Shell）排序【缩小增量排序】" class="headerlink" title="（2）希尔（Shell）排序【缩小增量排序】"></a>（2）希尔（Shell）排序【缩小增量排序】</h4><p>【基本思想】<br>在插入排序中，只比较相邻的结点，一次比较最多把结点移动一个位置。如果对位置间隔较大距离的结点进行比较，使得结点在比较以后能够一次跨过较大的距离，这样就可以提高排序的速度。</p>
<h5 id="1°算法介绍-1"><a href="#1°算法介绍-1" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>设待排序的对象序列有n个对象，首先取一个整数gap&lt;n作为增量，将全部对象分为gap个子序列，所有距离为gap的对象放在同一个序列中，在每一个子序列中分别施行直接插入排序。<br>然后缩小增量gap，如取gap=gap/2。<br>重复上述的子序列划分和排序工作，直到最后取gap为1为止。<br>【即：先分组，在每一组内进行（序列长度较小）的插入排序，再逐渐增加序列长度，进行微调。即对于逐渐有序的总序列不断进行插入排序】</p>
<h5 id="2°性能分析-1"><a href="#2°性能分析-1" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>希尔排序的时间复杂度不确定。【难以分析】<br>在O(n(3/2))~O（n（log2n)2）区间内<br>【希尔排序，是不稳定的排序方法。因为“不相邻记录间的移动”，可能改变相同关键字的次序】</p>
<h3 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h3><p>【原理】：将待排序的结点分为已排序(初始为空)和为未排序两组，依次将未排序的结点中值最小的结点插入已排序的组中。</p>
<h4 id="（1）直接（简单）选择排序"><a href="#（1）直接（简单）选择排序" class="headerlink" title="（1）直接（简单）选择排序"></a>（1）直接（简单）选择排序</h4><h5 id="1°算法介绍-2"><a href="#1°算法介绍-2" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>首先在所有元素中用逐个比较的方法选出最小元素，把它与第一个元素交换；然后在剩下的元素中再次用逐个比较的方法选出最小元素，把它与第二个元素交换；以此类推，直到所有元素放入正确的位置。</p>
<p>对k个元素而言，每次选出最小元素需要k-1次比较。因此排序一个n个元素组成的序列所需的比较次数为：<br>(n-1) + (n-2)+ …… + 2 + 1  = n(n-1)/2 = O(n2)<br>【即采用“先找最小，再和第x序列交换”的方式】<br>直接选择排序是稳定的。</p>
<h4 id="（2）树形选择"><a href="#（2）树形选择" class="headerlink" title="（2）树形选择"></a>（2）树形选择</h4><h5 id="1°算法介绍-3"><a href="#1°算法介绍-3" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>【这是对简单选择排序，利用上次结果，加以改进的方法】<br>对于次小元素，利用上次的结果，即被13打败的结点中进行比较。具体而言，可以将叶结点中的最小值改为∞，重新比较。</p>
<h5 id="2°性能分析-2"><a href="#2°性能分析-2" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>考虑关键字的比较次数和对象移动次数。<br>比较次数为 O(log2n)（最小关键字需 n-1 次）<br>对象的移动次数不超过比较次数。<br>所以，总的时间复杂度为O(n log2n)空间复杂度为O(n)<br>树形选择排序是稳定的排序方法。<br>缺点：辅助存储空间较多，和最大值进行多余的比较。<br>【树形选择排序可以进一步优化为堆排序，通常不作为“八大排序算法”之一】</p>
<h4 id="（3）堆排序"><a href="#（3）堆排序" class="headerlink" title="（3）堆排序"></a>（3）堆排序</h4><p>【堆分为最小化堆/最大化堆，首先是完全二叉树】<br>对于最小/最大化堆，每个父亲都小于/大于它的2个儿子；儿子之间大小关系不一定；上下层之间也不一定。<br>【需写成完全二叉树的形式再进行判别】</p>
<h5 id="1°算法介绍-4"><a href="#1°算法介绍-4" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>使用递归实现。<br>-初始建堆，并调整至最大化/最小化堆<br>-将堆根的元素（最大/最小元素）依次和最右、最下的元素互换（逆层序遍历）<br>【也可以将最大元素去除，并重新调整堆（算法2）】<br>-只剩最后1个元素时，结束。</p>
<h5 id="2°性能分析-3"><a href="#2°性能分析-3" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>时间复杂度：<br>时间耗费的代价：建堆的时间耗费＋排序的时间耗费。<br>前者的T(n) = O (n) 【约4n】<br>后者的T(n) = O (nlogn)<br>最后所得的T(n) = O (nlogn)，这里取大的。【系数大约是2】。<br>最坏情况下，时间复杂度为O(nlogn) ，比快速排序优。但平均情况下，比快速排序差<br>空间复杂度：O(1)，仅需一个记录大小供交换用的辅助存储空间<br>不稳定。<br>【堆排序和快速排序各有所长。最坏情况下的时间复杂度不会退化，但平均情况下的时间复杂度系数比快速排序要大】</p>
<h3 id="3、交换排序（快速排序、冒泡排序）"><a href="#3、交换排序（快速排序、冒泡排序）" class="headerlink" title="3、交换排序（快速排序、冒泡排序）"></a>3、交换排序（快速排序、冒泡排序）</h3><p>【原理】<br>根据序列中两个数据元素的比较结果，确定是否交换这两个数据元素在序列中的位置。<br>【特点】：通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动。</p>
<h4 id="（1）冒泡排序"><a href="#（1）冒泡排序" class="headerlink" title="（1）冒泡排序"></a>（1）冒泡排序</h4><h5 id="1°算法介绍-5"><a href="#1°算法介绍-5" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一ci次【起泡】。</p>
<p>然后再从头开始，对倒数第二个元素进行第二次起泡。经过了第二次比较，又将第二大的元素放到了倒数第二个位置。依次类推，经过第n-1次起泡，将倒数第n-1个大的元素放入第2个单元。<br>【注：冒泡排序中，使用1个标志位，来记录起泡中有没有发生过交换（初值为False，如果交换则设定为True）；如果没有，则前面的是已排序的】-作为【结束条件】</p>
<h5 id="2°性能分析-4"><a href="#2°性能分析-4" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>【最坏情况，进行n-1次起泡操作，第i次起泡，需n-1次比较、n-i次交换。O(N2)】<br>【最好情况，顺序，1次起泡，n-1次比较（此时标志位没有变化，循环结束），O(N)】<br>【平均情况，时间复杂度 O(N2)】<br>冒泡排序【适合原始数据较为有序的情况】<br>**和简单选择排序较为相似。</p>
<h4 id="（2）快速排序"><a href="#（2）快速排序" class="headerlink" title="（2）快速排序"></a>（2）快速排序</h4><h5 id="1°算法介绍-6"><a href="#1°算法介绍-6" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>在待排序的序列中选择一个数据元素，以该元素为标准，将所有数据元素分为两组，第一组的元素均小于或等于标准元素，第二组的数据元素均大于标准元素。<br>第一组的元素放在数组的前面部分，第二组的数据元素放在数组的后面部分，标准元素放在中间。这个位置就是标准元素的最终位置。这称为一次划分。<br>然后对分成的两组数据重复上述过程，直到所有的元素都在适当的位置为止。<br>【采用递归算法实现】</p>
<p>选择中心点<br>-用待排序序列的第一个元素作为标准元素。【如果输入随机，可以接受；这个对有序情况是糟糕的划分。】<br>-【选择N个数的中值，保证均匀划分（可以通过采样得到）】<br>-【最左、最右、中间3个元素值处于中间的作为枢轴】</p>
<p>如何划分<br>-从右向左开始检查。如果high的值大于k，该位置中的值位置正确，high减1，继续往前检查，直到遇到一个小于k的值。<br>-将小于k的这个值放入low的位置。此时high的位置又空出来了。然后从low位置开始从左向右检查，直到遇到一个大于k的值。<br>-将low位置的值放入high位置，重复第一步，直到low和high重叠。将k放入此位置。</p>
<p>【即：先从右往左，如果是大于k则过，high左移；如果小于k，则把值和low互换。再从左往右继续找小于k的，同理进行。直到有大于k的，把这个值放入high位置，重复第一步。直到low和high重叠（low≥high）。】<br>【先排序；再分别排序左、右一半】</p>
<h5 id="2°性能分析-5"><a href="#2°性能分析-5" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>【最坏情况，中心点最小或最大，时间复杂度O(N2)】<br>【最好情况，中心点划分成两个相同规模子集，O(N logN)】-两边同时除以N，求和】<br>【平均情况，O(N logN)】<br>**【通常认为，快速排序是在平均情况下最佳的排序方法。】<br>缺陷：<br>-枢轴选择不当可能导致最坏情况出现。<br>-差不多排好序时，采用直接插入排序、起泡排序等方法。<br>-递归改为非递归<br>空间复杂度不超过logN。</p>
<h3 id="4、归并排序"><a href="#4、归并排序" class="headerlink" title="4、归并排序"></a>4、归并排序</h3><p>【原理】<br>来自于【归并有序表/有序链表】<br>-顺序比较对应元素，小者移入另一表/新表（可采用指针移动，链表同理）<br>-一表空，另一表剩余结点自左至右复制/直接链表链上去。</p>
<h5 id="1°算法介绍-7"><a href="#1°算法介绍-7" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>若N = 1，已排序。<br>否则，<br>-前一半和后一半分别归并排序<br>-归并两个已排序数组<br>【递归分治，参数是排序的区间】<br>-可以采用以下函数。<br>MSort( RcdType SR[ ], RcdType &amp;TR1[ ], int s, int t  )【将 SR[s..t] 归并为 TR1 [ s..t]】SR代表原来的【序列】；TR1代表之后的【序列】。s代表头结点，t代表尾结点。<br>if  ( s == t ) TR1[s] = SR[s];     else</p>
<pre><code>{  m = ( S+ t)/2 ;        // 将SR[s..t]分为SR[s..m]和SR[m+1..t]
      Msort(SR,TR2,s,m);        // 递归地将SR[s..m]归并为有序的TR2[s..m]
      Msort(SR,TR2,m+1, t);    // 递归地将SR[m+1..t]归并为有序的TR2[m+1..t] 

  Merge(TR2,TR1,s,m, t);   // 将TR2[s..m]和TR2[m+1..t] 归并到TR1[s..t]
   }
</code></pre><h5 id="2°性能分析-6"><a href="#2°性能分析-6" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>【归并次数：log N，每次比较的代价N；总时间代价为O(N logN)】<br>空间复杂度：O(N)<br>稳定。</p>
<h3 id="5、基数排序"><a href="#5、基数排序" class="headerlink" title="5、基数排序"></a>5、基数排序</h3><p>【原理】<br>把单关键字按基数分成“多关键字”来排序。</p>
<h5 id="1°算法介绍-8"><a href="#1°算法介绍-8" class="headerlink" title="1°算法介绍"></a>1°算法介绍</h5><p>多关键字排序：<br>【多个关键字排序时，关键字之间的关系是按字段升/降序的，而不是加权】<br>（即：最主＞次主＞……＞最次）<br>-最高位优先【MSD】<br>先对最高位排序，按不同值将记录序列分为若干子序列，再对次高位排序，……最后对最次位关键字排序。<br>-最低位优先【LSD】<br>先对最低位排序，再……这样不需要根据“前一个”关键字的排序结果，将记录序列分割成若干个(“前一个”关键字不同的)子序列。<br>【即：先按每个关键字分开排序；再按某种特定方式（从高到低）收集】<br>e.g.对一群不大于1000的数排序。【要确定规则】<br>-先看位数分类（分开）<br>-再按最高位、次高位等确定大小（排序）<br>-多位比少位大，高位数大的大（收集）</p>
<h5 id="2°性能分析-7"><a href="#2°性能分析-7" class="headerlink" title="2°性能分析"></a>2°性能分析</h5><p>【时间复杂度：每个结点d位关键字，d次分配和收集】<br>分配：O(N)，收集O(rd)。总代价为O(d* (n+rd))</p>
<h2 id="三、【各种内部排序方法比较】"><a href="#三、【各种内部排序方法比较】" class="headerlink" title="三、【各种内部排序方法比较】"></a>三、【各种内部排序方法比较】</h2><h3 id="1、时间性能"><a href="#1、时间性能" class="headerlink" title="1、时间性能"></a>1、时间性能</h3><p>（1）【按平均时间性能】：<br>O(nlogn)的方法有：【快速排序、堆排序和归并排序】，其中以【快速排序】为最好；<br>O(n2)的方法有：【直接插入排序、起泡排序和简单选择排序】，其中以【直接插入】为最好，特别是对那些对关键字近似有序的记录序列尤为如此。<br>时间复杂度为O(n)的排序方法只有，基数排序。<br>【这里不考虑希尔排序】</p>
<p>（2）【待排记录序列按关键字顺序有序】：<br>【直接插入排序和起泡排序】能达到O(n)的时间复杂度。<br>对快速排序而言，这是最不好的情况，此时的时间性能蜕化为O(n2)，应尽量避免。</p>
<p>（3）【简单选择排序、堆排序和归并排序】的时间性能不随序列中关键字的分布而改变。<br>（2、3两部分没有考虑希尔排序、基数排序）</p>
<h3 id="2、空间性能"><a href="#2、空间性能" class="headerlink" title="2、空间性能"></a>2、空间性能</h3><p>（1）所有的【简单排序方法(包括：直接插入、起泡和简单选择)和堆排序】的空间复杂度为O(1)；<br>（2） 快速排序为O(logn)，为栈所需的辅助空间；<br>（3） 【归并排序所需辅助空间最多】，其空间复杂度为O(n)；<br>（4）【链式基数排序需附设队列首尾指针】，则空间复杂度为O(n+2rd)。</p>
<h3 id="3、稳定性"><a href="#3、稳定性" class="headerlink" title="3、稳定性"></a>3、稳定性</h3><p>前面的3大类排序，都是简单的稳定，复杂（相对高效）的不稳定。</p>
<h4 id="（1）稳定："><a href="#（1）稳定：" class="headerlink" title="（1）稳定："></a>（1）稳定：</h4><p>-直接插入排序（折半插入）<br>-直接选择排序（树形选择排序）<br>-冒泡排序<br>-归并排序<br>-基数排序</p>
<h4 id="（2）不稳定："><a href="#（2）不稳定：" class="headerlink" title="（2）不稳定："></a>（2）不稳定：</h4><p>-希尔排序<br>-堆排序<br>-快速排序</p>
<h3 id="4、关于“比较关键字”原理排序的时间复杂度"><a href="#4、关于“比较关键字”原理排序的时间复杂度" class="headerlink" title="4、关于“比较关键字”原理排序的时间复杂度"></a>4、关于“比较关键字”原理排序的时间复杂度</h3><p>除基数排序外，其它方法都是基于“比较关键字”进行排序的排序方法，可以证明，这类排序法可能达到的最快的时间复杂度为O(nlogn)。(基数排序不是基于“比较关键字”的排序方法,所以它不受这个限制)</p>
<h6 id="孙可扬sky"><a href="#孙可扬sky" class="headerlink" title="孙可扬sky"></a>孙可扬sky</h6><h6 id="2017-3-4"><a href="#2017-3-4" class="headerlink" title="2017.3.4"></a>2017.3.4</h6>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近复习数据结构与算法，归纳整理一下八大排序算法。&lt;/p&gt;
&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;h3 id=&quot;1、什么是排序&quot;&gt;&lt;a href=&quot;#1、什么是
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AVT Vimba与OpenCV环境配置</title>
    <link href="http://supermastersky.com/2017/02/07/AVT-Vimba%E4%B8%8EOpenCV%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://supermastersky.com/2017/02/07/AVT-Vimba与OpenCV环境配置/</id>
    <published>2017-02-07T09:03:57.000Z</published>
    <updated>2017-04-06T13:46:23.486Z</updated>
    
    <content type="html"><![CDATA[<p>由于实验室项目需求，需在windows7x64环境下，使用一款大恒AVT相机采集图像并进行web编程等后续处理。环境的配置过程较为繁杂，过年期间，进行一下内容整理。<br>&lt;–!more–&gt;</p>
<h3 id="安装目录："><a href="#安装目录：" class="headerlink" title="安装目录："></a>安装目录：</h3><h5 id="1、Anaconda2-4-2-0-Windows-x86-64（自带python2-7及scipy、numpy等库）"><a href="#1、Anaconda2-4-2-0-Windows-x86-64（自带python2-7及scipy、numpy等库）" class="headerlink" title="1、Anaconda2-4.2.0-Windows-x86_64（自带python2.7及scipy、numpy等库）"></a>1、Anaconda2-4.2.0-Windows-x86_64（自带python2.7及scipy、numpy等库）</h5><h5 id="2、pycharm-professional-2016-2-3"><a href="#2、pycharm-professional-2016-2-3" class="headerlink" title="2、pycharm-professional-2016.2.3"></a>2、pycharm-professional-2016.2.3</h5><h5 id="3、Opencv3-1-0"><a href="#3、Opencv3-1-0" class="headerlink" title="3、Opencv3.1.0"></a>3、Opencv3.1.0</h5><h5 id="4、opencv-python-3-1-0-cp27-cp27m-win-amd64（opencv3-1-0环境库）"><a href="#4、opencv-python-3-1-0-cp27-cp27m-win-amd64（opencv3-1-0环境库）" class="headerlink" title="4、opencv_python-3.1.0-cp27-cp27m-win_amd64（opencv3.1.0环境库）"></a>4、opencv_python-3.1.0-cp27-cp27m-win_amd64（opencv3.1.0环境库）</h5><h5 id="5、AVT-vimba-1-3以上版本（内附2-0）"><a href="#5、AVT-vimba-1-3以上版本（内附2-0）" class="headerlink" title="5、AVT_vimba 1.3以上版本（内附2.0）"></a>5、AVT_vimba 1.3以上版本（内附2.0）</h5><h5 id="6、pymba-master"><a href="#6、pymba-master" class="headerlink" title="6、pymba-master"></a>6、pymba-master</h5><h4 id="搭建环境：Windows7x64-Python2-7-OpenCV3-1-0-AVT-vimba2-0"><a href="#搭建环境：Windows7x64-Python2-7-OpenCV3-1-0-AVT-vimba2-0" class="headerlink" title="搭建环境：Windows7x64 + Python2.7 + OpenCV3.1.0+AVT vimba2.0"></a>搭建环境：Windows7x64 + Python2.7 + OpenCV3.1.0+AVT vimba2.0</h4><h3 id="一、Python2-7"><a href="#一、Python2-7" class="headerlink" title="一、Python2.7"></a>一、Python2.7</h3><h4 id="1、python2-7软件安装（安装Anaconda2-4-2-0-Windows-x86-64）"><a href="#1、python2-7软件安装（安装Anaconda2-4-2-0-Windows-x86-64）" class="headerlink" title="1、python2.7软件安装（安装Anaconda2-4.2.0-Windows-x86_64）"></a>1、python2.7软件安装（安装Anaconda2-4.2.0-Windows-x86_64）</h4><p>在python2系列中，Python2.7的软件支持效果较好，特别是python2.7.4和2.7.10，这两个子版本的应用非常广泛。可直接于Python官网直接下载安装，再安装scipy、numpy等各类支持库。<br>而由于Anaconda包含python7.7.10和各类库，可直接安装使用，故选择安装Anaconda。直接打开安装程序，按默认设置进行安装即可，注意记录安装路径。</p>
<h4 id="2、编译器pucharm安装（pycharm-professional-2016-2-3）"><a href="#2、编译器pucharm安装（pycharm-professional-2016-2-3）" class="headerlink" title="2、编译器pucharm安装（pycharm-professional-2016.2.3）"></a>2、编译器pucharm安装（pycharm-professional-2016.2.3）</h4><p>安装python编译器pycharm。直接双击打开安装程序，按默认设置进行安装即可。</p>
<h3 id="二、OpenCV3-1-0"><a href="#二、OpenCV3-1-0" class="headerlink" title="二、OpenCV3.1.0"></a>二、OpenCV3.1.0</h3><h4 id="1、opencv3-1-0安装"><a href="#1、opencv3-1-0安装" class="headerlink" title="1、opencv3.1.0安装"></a>1、opencv3.1.0安装</h4><p>安装包在OpenCV官网下载可得，安装过程其实只是简单的解压缩，同样需注意记录安装路径。<br>安装完毕后，需进行环境变量配置。将opencv\build\x64\vc12\bin加入到计算机path内。具体操作为，我的电脑（右键）——属性——高级系统设置——环境变量——Path（双击），添加环境变量。<br>由于使用Python API，再把opencv\build\python\2.7\x64目录下的cv2.pyd文件，复制到前述Anaconda文件对应的Lib\site-packages目录下，完成系统注册表配置。这样就完成了基本的python与opencv链接。</p>
<h4 id="2、opencv-python链接库安装（opencv-python-3-1-0-cp27-cp27m-win-amd64）"><a href="#2、opencv-python链接库安装（opencv-python-3-1-0-cp27-cp27m-win-amd64）" class="headerlink" title="2、opencv-python链接库安装（opencv_python-3.1.0-cp27-cp27m-win_amd64）"></a>2、opencv-python链接库安装（opencv_python-3.1.0-cp27-cp27m-win_amd64）</h4><p>这是opencv3.1.0环境库。由于在实际使用时，发现64位系统在仅安装python和opencv时，会存在无法实现调用的问题，故安装此链接库。<br>安装方式为，进入windows命令行界面，在切换到此文件的目录下后，运行pip install 命令，输入语句pip install opencv_python-3.1.0-cp27-cp27m-win_amd64.whl，以进行链接库安装。</p>
<h3 id="三、AVT-Vimba"><a href="#三、AVT-Vimba" class="headerlink" title="三、AVT Vimba"></a>三、AVT Vimba</h3><h4 id="1、AVT-vimba-1-3以上版本（使用2-0）安装"><a href="#1、AVT-vimba-1-3以上版本（使用2-0）安装" class="headerlink" title="1、AVT_vimba 1.3以上版本（使用2.0）安装"></a>1、AVT_vimba 1.3以上版本（使用2.0）安装</h4><p>这是大恒AVT相机的官方驱动程序，可于AVT官网下载并安装。我所安装的是2.0版本。</p>
<h4 id="2、pymba-master安装"><a href="#2、pymba-master安装" class="headerlink" title="2、pymba-master安装"></a>2、pymba-master安装</h4><p>官方仅提供了C/C++的API，因此想使用Python的同学通常可使用ctypes，或使用pymba。<br>在田家田师兄的推荐下，我使用pymba进行python调用。这里要感谢伟大的Github，给我们节约了无数的时间【pymba的原github地址赋予本文最后】。<br>这里，将pymba安装到第一步，已安装的Anaconda\Lib\site-packages目录下。<br>这里安装过程同pip，下载解压到某个文件夹后，使用cmd shell，cd切换到相应目录，输入python setup.py install。如图所示。<br><img src="D:/blog/source/_posts/photoes/1.png" alt="1"><br>完成pymba安装后，需更改pymba默认索引的VimbaC.dll的路径。具体更改方法为找到/pymba/vimbadll.py将其中的Line13和Line16更改为自己VimbaC.dll的路径，修改为return r’（vimba安装路径）\Vimba_2.0\VimbaC\Bin\Win64\VimbaC.dll’，完成安装。我的如下图所示：<br><img src="D:/blog/source/_posts/photoes/2.png" alt="2"><br>重新编译后，就大功告成了~~</p>
<h5 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h5><p>1、田家田师兄博客<a href="http://onlytjt.github.io/2015/11/17/OpenCV_Vimba/" target="_blank" rel="external">http://onlytjt.github.io/2015/11/17/OpenCV_Vimba/</a><br>2、pymba的Github地址，<a href="https://github.com/morefigs/pymba" target="_blank" rel="external">https://github.com/morefigs/pymba</a></p>
<h6 id="孙可扬sky"><a href="#孙可扬sky" class="headerlink" title="孙可扬sky"></a>孙可扬sky</h6><h6 id="2017-2-7"><a href="#2017-2-7" class="headerlink" title="2017.2.7"></a>2017.2.7</h6>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于实验室项目需求，需在windows7x64环境下，使用一款大恒AVT相机采集图像并进行web编程等后续处理。环境的配置过程较为繁杂，过年期间，进行一下内容整理。&lt;br&gt;&amp;lt;–!more–&amp;gt;&lt;/p&gt;
&lt;h3 id=&quot;安装目录：&quot;&gt;&lt;a href=&quot;#安装目录：&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个开始</title>
    <link href="http://supermastersky.com/2016/09/24/%E4%B8%80%E4%B8%AA%E5%BC%80%E5%A7%8B/"/>
    <id>http://supermastersky.com/2016/09/24/一个开始/</id>
    <published>2016-09-24T13:36:42.000Z</published>
    <updated>2017-04-06T13:46:17.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开篇记"><a href="#开篇记" class="headerlink" title="开篇记"></a>开篇记</h3><p>习惯性在开始的时候写些什么，却又不知从何说起。<br>日记自2015年8月起，已经记了一年有余，总字数超过了十万。日记是日记，并没有公开的计划，即使有也是不知多久以后了。<br>总要有些公开的文字，与或多或少、常见或未见的朋友们，面谈或神交。<br>开博客的举措曾进行过数次。最早的QQ空间，交互做得相当不错，而由于qq的渐用渐少而废弃。本科时用人人网，尽心写过不少日志，而本科毕业后删的删屏蔽的屏蔽，留下的固然是自己认为的精品，却不知未来看到会不会觉得是年少轻狂的绝妙讽刺。<br>现在的日常交往，有微信朋友圈，却在某种程度上只是固化自己的朋友圈子；而自身在行业内，多多少少了解，自己所看到的新闻，绝大多数是大数据环境下别人认为自己所想看到的。真正的世界观能扩展多少，不得而知。<br>田师兄推荐了github，也许可以用来展示自己的些许编程思路，与网上各位大牛分享代码，有所困惑也许还能收获指点，算是意外惊喜吧。<br>确实，今天光是调试环境就用了不少时间，希望能展示一些自己的想法，还请各路大神不吝赐教吧。<br>大家都有自己的选择与道路，我也应时刻保持进步。</p>
<h6 id="孙可扬sky"><a href="#孙可扬sky" class="headerlink" title="孙可扬sky"></a>孙可扬sky</h6><h6 id="2016-9-24"><a href="#2016-9-24" class="headerlink" title="2016.9.24"></a>2016.9.24</h6>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;开篇记&quot;&gt;&lt;a href=&quot;#开篇记&quot; class=&quot;headerlink&quot; title=&quot;开篇记&quot;&gt;&lt;/a&gt;开篇记&lt;/h3&gt;&lt;p&gt;习惯性在开始的时候写些什么，却又不知从何说起。&lt;br&gt;日记自2015年8月起，已经记了一年有余，总字数超过了十万。日记是日记，并没有
    
    </summary>
    
    
  </entry>
  
</feed>
