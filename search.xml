<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title></title>
      <url>http://supermastersky.com/2017/04/05/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="八大排序算法总结"><a href="#八大排序算法总结" class="headerlink" title="八大排序算法总结"></a>八大排序算法总结</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1、什么是排序"><a href="#1、什么是排序" class="headerlink" title="1、什么是排序"></a>1、什么是排序</h3><p>所谓排序，就是把集合中的数据元素，按它们的关键字非递减或非递增序，排成一个序列。</p>
<h3 id="2、排序的分类"><a href="#2、排序的分类" class="headerlink" title="2、排序的分类"></a>2、排序的分类</h3><h4 id="内排序和外排序"><a href="#内排序和外排序" class="headerlink" title="内排序和外排序"></a>内排序和外排序</h4><p>按排序数据元素的的位置，可将排序分为内排序与外排序两类。<br>-内排序是指被排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置。<br>-外排序是指在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置。通常在排序数据较大情况下，内存不足以放入所有数据进行处理，此时需考虑进行外排序。<br>通常所说的【八大排序】均指内部排序（在内存中进行的排序）。</p>
<h4 id="稳定排序和非稳定排序"><a href="#稳定排序和非稳定排序" class="headerlink" title="稳定排序和非稳定排序"></a>稳定排序和非稳定排序</h4><p>稳定与非稳定排序：假定在待排序的集合中存在多个【关键字值相同】的数据元素。如果经过排序后，【这些数据元素的相对次序保持不变，则称为稳定排序；否则称为不稳定排序。】</p>
<p>先讨论内部排序。<br>按内部排序过程中的工作量进行排序：<br>（1）简单的。时间复杂度O(N2)<br>（2）先进的。时间复杂度O(NlogN)<br>（3）基数排序。时间复杂度O(D.N)</p>
<p>两种基本操作：<br>-关键字比较：对大多数排序方法来说是必要的。<br>-记录移动：可通过改变记录的存储方式来予以避免。<br>存储方式1：顺序存储结构<br>存储方式2：静态链表。关系次序由指针指示，排序时不移动记录，仅修改指针。<br>存储方式3：地址排序。排序过程中不移动记录，移动地址向量中的地址。排序结束后再按照地址向量值调整位置。</p>
<p>1、插入排序<br>【原理】：首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的n-1个元素依次插入到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的。<br>【打牌，左手的牌数量从0-n，每增长一个都是有序的】<br>a、直接插入排序<br>假定待排序的是数组a，它共有n个 数组元素。那么对于每个1 &lt;=j&lt;n的j，将 a[j]插入到已经排好序的序列a[0]，a[1], a[2],……, a[j-1] 中去。</p>
<p>首先将a[j]放入到一个某个变量tmp中。然后从右到左与a[j-1]……, a[2], a[1], a[0]，进行比较。<br>-<br>若tmp &lt; a[j-1]，将a[j-1]的内容移到a[j]中去。<br>-<br>若 x  &lt; a[j-2]，将a[j-2]的内容移到a[j-1]中去。</p>
<p>-重复这个过程，直至找到比tmp小的数组元素a[k]，将tmp存入a[k+1]。</p>
<p>-如果一直找到a[0]都没有找到一个小于tmp的值，将tmp存入a[0]。<br>【也就是从右向左逐个比较，若比原位置大就停；否则原位置的右移，再和左边的比】<br>【时间复杂度是O(N2)】。该上限是可达的。当输入是逆序的时候，达到上限<br>当输入已排序时，运行时间是O(N)。因为内层循环只执行一个周期（最好情况）<br>正序时比较次数n-1，移动0；逆序时最差。<br>平均n2/4，O(n2)<br>-稳定。关键字相同的2个，不会通过比较而互换。<br>-适用范围及改进：<br>简单易于实现；<br>【适用于】排序元素较少，且【几乎已排序（接近正序）】。</p>
<p>b、希尔（Shell）排序【缩小增量排序】<br>【基本思想】<br>在插入排序中，只比较相邻的结点，一次比较最多把结点移动一个位置。如果对位置间隔较大距离的结点进行比较，使得结点在比较以后能够一次跨过较大的距离，这样就可以提高排序的速度。<br>【算法】<br>设待排序的对象序列有n个对象，</p>
<p>首先取一个整数gap&lt;n作为增量，</p>
<p>将全部对象分为gap个子序列，所有距离为gap的对象放在同一个序列中，在每一个子序列中分别施行直接插入排序，</p>
<p>然后缩小增量gap，如取gap=gap/2，</p>
<p>重复上述的子序列划分和排序工作，直到最后取gap为1为止。【即：先分组，在每一组内进行（序列长度较小）的插入排序，再逐渐增加序列长度，进行微调。即对于逐渐有序的总序列不断进行插入排序】<br>-时间复杂度不确定。【难以分析】<br>O(n(3/2))~O（n（log2n)2）<br>【希尔排序，是不稳定的排序方法。因为“不相邻记录间的移动”】</p>
<p>（c、折半插入排序）<br>【<br>最坏情况下总的比较次数还是O（n2）】<br>利用二分查找法，快速地找到a[j]的插入位置。从而达到减少比较次数的目的。<br>平均O(n2)<br>-折半插入排序同样稳定。原理同样不会交换。<br>**对于2-路插入排序，比较次数nlog2(n)，移动次数n2/8。</p>
<p>2、选择排序<br>【原理】：将待排序的结点分为已排序(初始为空)和为未排序两组，依次将未排序的结点中值最小的结点插入已排序的组中。<br>a、直接（简单）选择排序<br>首先在所有元素中用逐个比较的方法选出最小元素，把它与第一个元素交换；然后在剩下的元素中再次用逐个比较的方法选出最小元素，把它与第二个元素交换；以此类推，直到所有元素都放入了正确的位置。</p>
<p>对k个元素而言，每次选出最小元素需要k-1次比较。因此排序一个n个元素组成的序列所需的比较次数为：<br>(n-1) + (n-2)+ …… + 2 + 1  = n(n-1)/2 = O(n2)<br>【即采用“先找最小，再和第x序列交换”的方式】<br>直接选择排序是稳定的。</p>
<p>（b、树形选择）<br>【这是对简单选择排序，利用上次结果，加以改进的方法】<br>对于次小的，利用上次的结果，即被13打败的结点中进行比较。具体而言，可以将叶结点中的最小值改为∞，重新比较。<br>考虑关键字的比较次数和对象移动次数</p>
<ol>
<li>比较次数为 O(log2n)（最小关键字需 n-1 次）</li>
<li>对象的移动次数不超过比较次数。</li>
</ol>
<p>所以总的时间复杂度为O(n log2n)空间复杂度为O(n)</p>
<p>树形选择排序是稳定的排序方法。<br>缺点：辅助存储空间较多，和最大值进行多余的比较。【可以再优化为堆排序】</p>
<p>c、堆排序<br>【堆：最小化堆/最大化堆，首先是完全二叉树】<br>-每个父亲都小于/大于它的2个儿子；儿子之间大小关系不一定；上下层之间也不一定<br>【需写成完全二叉树的形式再进行判别】<br>算法：<br>*清华：<br>-初始建堆，并调整至最大化/最小化堆<br>-将堆根的元素（最大/最小元素）依次和最右、最下的元素互换（逆层序遍历，清华算法）<br>【也可以将最大元素去除，并重新调整堆，deQueue（交大算法）】<br>-只剩最后1个元素时，结束。<br>【sort、just两步，使用递归！】<br>清华：ch10，P187；<br>交大：<br>堆排序和优先级队列中的堆有三个细小的区别：<br>-<br>堆排序用的是最大堆-为了和其他的排序函数保持一致，数据从位置【0】开始存储。因此，对位置i中的结点，父结点在位置（i–1）/ 2，左孩子在位置2i + 1，右孩子紧跟着左孩子2i + 2<br>-<br>在向下过滤时需要告知当前堆的大小</p>
<p>假设有了一个向下过滤的函数percolateDown，它有三个参数：第一个参数是待排序的数组，第二个参数是向下过滤的起始位置，第三个是目前堆的大小</p>
<p>**【之后统一查询【python实现】= =】<br>时间复杂度：<br>时间耗费的代价：建堆的时间耗费＋排序的时间耗费。<br>前者的T(n) = O (n) 【约4n】<br>后者的T(n) = O (nlogn)<br>最后所得的T(n) = O (nlogn)，这里取大的。【系数大约是2】。<br>最坏情况下，时间复杂度为O(nlogn) ，比快速排序优。但平均情况下，比快速排序差<br>空间复杂度：O(1)，仅需一个记录大小供交换用的辅助存储空间<br>不稳定。<br>【和快速排序各有所长】</p>
<p>3、交换排序（快速排序、冒泡排序）<br>根据序列中两个数据元素的比较结果，确定是否交换这两个数据元素在序列中的位置。</p>
<p>【交换排序的特点】：通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动。<br>a、冒泡<br>从头到尾比较相邻的两个元素，将小的换到前面，大的换到后面。经过了从头到尾的一趟比较，就把最大的元素交换到了最后一个位置。这个过程称为一趟【起泡】。</p>
<p>然后再从头开始到倒数第二个元素进行第二趟起泡。经过了第二趟比较，又将第二大的元素放到了倒数第二个位置。依次类推，经过第n-1趟起泡，将倒数第n-1个大的元素放入第2个单元。<br>【注：冒泡排序中，使用1个标志位，来记录起泡中有没有发生过交换（初值为False，如果交换则设定为True）；如果没有，则前面的是已排序的】-作为【结束条件】<br>【最坏情况，进行n-1次起泡操作，第i次起泡，需n-1次比较、n-i次交换。O(N2)】<br>【最好情况，顺序，1次起泡，n-1次比较（此时标志位没有变化，循环结束），O(N)】<br>【平均情况，时间复杂度 O(N2)】<br>【适合原始数据较为有序的情况】<br>**和简单选择排序较为相似。</p>
<p>b、快速排序<br>在待排序的序列中选择一个数据元素，以该元素为标准，将所有数据元素分为两组，第一组的元素均小于或等于标准元素，第二组的数据元素均大于标准元素。第一组的元素放在数组的前面部分，第二组的数据元素放在数组的后面部分，标准元素放在中间。这个位置就是标准元素的最终位置。这称为一趟划分。然后对分成的两组数据重复上述过程，直到所有的元素都在适当的位置为止。<br>【递归算法】</p>
<ol>
<li>选择中心点<br>-用待排序序列的第一个元素作为标准元素。【如果输入随机，可以接受；这个对有序情况是糟糕的划分。】<br>-【选择N个数的中值，保证均匀划分（可以通过采样得到）】<br>-【最左、最右、中间3个元素值处于中间的作为枢轴】</li>
<li>如何划分<br>-从右向左开始检查。如果high的值大于k，该位置中的值位置正确，high减1，继续往前检查，直到遇到一个小于k的值。-将小于k的这个值放入low的位置。此时high的位置又空出来了。然后从low位置开始从左向右检查，直到遇到一个大于k的值。-将low位置的值放入high位置，重复第一步，直到low和high重叠。将k放入此位置。<br>【即：先从右往左，如果是大于k则过，high左移；如果小于k，则把值和low互换。再从左往右继续找小于k的，同理进行。直到有大于k的，把这个值放入high位置，重复第一步。直到low和high重叠（low≥high）。】参见P343。<br>【用一个能完成划分的函数divide，递归实现（先排序；再分别排序左、右一半）】<br>【最坏情况，中心点最小或最大，时间复杂度O(N2)】<br>【最好情况，中心点划分成两个相同规模子集，O(N logN)】-两边同时除以N，求和】<br>【平均情况，O(N logN)】<br><em>*</em>【通常认为是在平均情况下最佳的排序方法。】<br>缺陷：<br>-枢轴选择不当可能导致最坏情况出现。<br>-差不多拍好序时，采用直接插入排序、起泡排序等方法。<br>-递归改为非递归（= =）<br>空间复杂度不超过logN。</li>
</ol>
<p>4、归并排序<br>来自于【归并有序表/有序链表】<br>-顺序比较对应元素，小者移入另一表/新表（可采用指针移动，链表同理）<br>-一表空，另一表剩余结点自左至右复制/直接链表链上去<br>【归并排序】：<br>若N = 1，已排序。<br>否则，<br>-前一半和后一半分别归并排序<br>-归并两个已排序数组<br>【递归分治，参数是排序的区间】<br>-可以采用以下函数。<br>MSort( RcdType SR[ ], RcdType &amp;TR1[ ], int s, int t  )【将 SR[s..t] 归并为 TR1 [ s..t]】SR代表原来的【序列】；TR1代表之后的【序列】。s代表头结点，t代表尾结点。<br>if  ( s == t ) TR1[s] = SR[s];     else</p>
<pre><code>{  m = ( S+ t)/2 ;        // 将SR[s..t]分为SR[s..m]和SR[m+1..t]
      Msort(SR,TR2,s,m);        // 递归地将SR[s..m]归并为有序的TR2[s..m]
      Msort(SR,TR2,m+1, t);    // 递归地将SR[m+1..t]归并为有序的TR2[m+1..t] 

  Merge(TR2,TR1,s,m, t);   // 将TR2[s..m]和TR2[m+1..t] 归并到TR1[s..t]
   }
</code></pre><p>【归并次数：log N，每次比较的代价N；总时间代价为O(N logN)】<br>空间复杂度：O(N)<br>稳定。</p>
<p>5、基数排序<br>把单关键字按基数分成“多关键字”来排序。<br>多关键字排序：<br>【多个关键字排序时，关键字之间的关系是按字段升/降序的，而不是加权= =】<br>（即：最主＞次主＞……＞最次）<br>-最高位优先【MSD】<br>先对最高位排序，按不同值将记录序列分为若干子序列，再对次高位排序，……最后对最次位关键字排序。<br>-最低位优先【LSD】<br>先对最低位排序，再……这样不需要根据“前一个”关键字的排序结果，将记录序列分割成若干个(“前一个”关键字不同的)子序列。<br>【即：先按每个关键字分开排序；再按某种特定方式（从高到低）收集】<br>e.g.对一群不大于1000的数排序。【要确定规则】<br>-先看位数分类（分开）<br>-再按最高位、次高位等确定大小（排序）<br>-多位比少位大，高位数大的大（收集）<br>【时间复杂度：每个结点d位关键字，d次分配和收集】<br>分配：O(N)，收集O(rd)。总代价为O(d* (n+rd))</p>
<p>6、【各种内部排序方法比较】<br>a、时间性能<br>1.【按平均时间性能】：<br>O(nlogn)的方法有：【快速排序、堆排序和归并排序】，其中以【快速排序】为最好；<br>O(n2)的方法有：【直接插入排序、起泡排序和简单选择排序】，其中以【直接插入】为最好，特别是对那些对关键字近似有序的记录序列尤为如此<br>时间复杂度为O(n)的排序方法只有，基数排序。<br>【这里不考虑希尔排序】<br>2.【待排记录序列按关键字顺序有序】：<br>【直接插入排序和起泡排序】能达到O(n)的时间复杂度。<br>对快速排序而言，这是最不好的情况，此时的时间性能蜕化为O(n2)，应尽量避免。<br>3.【简单选择排序、堆排序和归并排序】的时间性能不随序列中关键字的分布而改变。<br>（2、3没有考虑希尔排序、基数排序）</p>
<p>b、空间性能</p>
<ol>
<li>所有的【简单排序方法(包括：直接插入、起泡和简单选择)和堆排序】的空间复杂度为O(1)；</li>
<li>快速排序为O(logn)，为栈所需的辅助空间；</li>
<li><p>【归并排序所需辅助空间最多】，其空间复杂度为O(n)；</p>
</li>
<li><p>【链式基数排序需附设队列首尾指针】，则空间复杂度为O(n+2rd)。</p>
</li>
</ol>
<p>c、【稳定性】<br>稳定：<br>-直接插入排序（折半插入）<br>-直接选择排序（树形选择排序）<br>-冒泡排序<br>-归并排序<br>-基数排序</p>
<p>不稳定：<br>-希尔排序<br>-堆排序<br>-快速排序<br>【前面3种大类排序，都是简单的稳定，复杂（高效）的不稳定= =】</p>
<p>d、【关于时间复杂度】<br>除基数排序外，其它方法都是基于“比较关键字”进行排序的排序方法，可以证明，这类排序法可能达到的最快的时间复杂度为O(nlogn)。(基数排序不是基于“比较关键字”的排序方法,所以它不受这个限制)。</p>
<p>7、外排序（对于磁带/磁盘上的数据）<br>模型：减少外存储器的读写。最常用的是【归并排序】（只需访问序列中第一个元素，适合于顺序文件）。<br>阶段：<br>a、预处理：根据内存大小将文件分批读入，用各种内排序算法排序，形成有序片段<br>【最简单的方法是按照内存的容量尽可能多地读入数据记录，然后在内存进行排序，排序的结果写入文件，形成一个已排序片段。</p>
<p>每次读入的记录数越小，形成的初始的已排序片段越多。而已排序片段越多，归并的次数也越多。】<br>【置换选择】：可在只能容纳p个记录的内存中，生成平均长度2p的初始已排序片段。<br>（用优先队列等）<br>-归并：逐步归并成有序文件。<br>可进行2路归并、多路归并等。略。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[AVT Vimba与OpenCV环境配置]]></title>
      <url>http://supermastersky.com/2017/03/29/AVT-Vimba%E4%B8%8EOpenCV%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>去年写的一篇文字，记录windows7x64环境下，大恒AVT相机的环境配置过程。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[一个开始]]></title>
      <url>http://supermastersky.com/2017/03/29/%E4%B8%80%E4%B8%AA%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<h2 id="千古江山，英雄无觅，孙大师处"><a href="#千古江山，英雄无觅，孙大师处" class="headerlink" title="千古江山，英雄无觅，孙大师处"></a>千古江山，英雄无觅，孙大师处</h2><p>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊<br>孙大师很厉害</p>
<h1 id="但是马总不知道要高到哪里去了"><a href="#但是马总不知道要高到哪里去了" class="headerlink" title="但是马总不知道要高到哪里去了"></a>但是马总不知道要高到哪里去了</h1>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://supermastersky.com/2017/03/28/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
